# wind 语法 
以S表达式为主，但是为了简洁和易于阅读, 数学运算(+ - * /)，逻辑运算(&& ||) 采用中缀表达式, 比如 (1 + 1)


## 类型
wind 语言是静态类型的, 基本类型有 bool, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64

以及对应的引用类型,只需在前面加一个 `'` (单引号), 比如 `'i32` 表示 i32 的引用类型(类似于 C 中的 int* 指针)


## 定义变量 & 类型标注

#### *`'`是类型标注符,可以出现在表达式后面, 每个表达式的类型都必须明确且唯一*

字面表达式可以缺省标注，比如 1 不标注的话默认为 `i32`, 1.0 为 `f64`
```
// 变量定义
(var x 1)
(var x 1'i8)

// 定义常量, const 表示该变量无法被更改
(const x 1)

// 自定义类型 (类似其他语言的 struct)
(type Point (x'i32 y'i32))

// 定义一个 bool 变量
(var b (!true && true || false))
```

## 赋值?
c系 语言中，普遍使用 `=` 来表示赋值，比如 `int a = 1;`

函数式语言中 则使用 (set a 1) 的方式

我觉得 `=` 从语义上，更像匹配判断，用来当作赋值并不恰当和形象, 而 set 表达式则不够简洁

所以 wind 采用 `<-` `->` 来进行赋值操作，`<-` 符号，形象的描述了数据的流向

```
(var a 1)
(a <- 2)    // 可以读作 2 流向 a

// 需要注意的是 (a <- 2) 是有值的，即 a 本身
// 下面的例子，等效于 a = b = c = 2
(a <- b <- c <- 2)
```

## 函数 & extern & lambda
`{...}` 是一个 block 表达式，它包含一组表达式，它会返回其中最后一个表达式的值
```
// 声明外部函数，无需行参名称
(extern (printf 'u8))    // 'u8 is a ptr to u8


// 定义一个函数
(define (foo a'i32 b'i32)'i32 {
    (const x (a + b))
    (const y (a - b))
    (x + y)
})


// 匿名函数(闭包) 类似于 define, 但是没有函数名字
(lambda (x'i32 y'i32)'i32 {
    (x + y)
})
```

## If 表达式
语法: (if testExpr thenExpr elseExpr)

注意: if 表达式是有返回值的。它相当于 C 的 (ok ? a : b)
```
(if (x + y > 0)
    {
        (print "x + y > 0")
    }
    {
        (print "x + y <= 0")
    }
)
```

## loop 表达式
语法: (loop [init] test body)

类似 C 语言的 while 循环, init 表达式会在循环开始时执行一次，且是可选的，init 中定义的变量也只能在 body 中使用

注意: loop 表达式是 void 类型，即没有返回值
```
(loop (var x 0) (x < 10) (x <- x + 1))
```


## 模式匹配 (match表达式)
语法: (match what case1 `=>` body1 case2 `=>` body2 ...)

case 表达式和 body 表达式是成对出现的

`_` 是个特殊的 case，可以匹配任意值, wind 要求 case 覆盖所有情况

注意: match 表达式 是有返回值的
```
(var x 1)

(match x 
    1 => (print "x == 1")
    2 => (print "x == 2")
    _ => (print "x == ?")
)
```

## 其他
还有一些语法没有提及, 比如 自定义类型(struct) 的属性和方法访问, 

数组的下标访问。这些应该和现代语言一致 比如 p.x, a[0]

```
待补充...
```