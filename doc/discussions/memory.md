<!-- 引用, 内存管理（无需GC, 吊打 Rust ?） -->

## 第一个问题, 什么是引用?
引用一下 Rust 文档 [A reference is like a pointer in that it’s an address we can follow to access the data stored at that address;](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#:~:text=A%20reference%20is%20like%20a%20pointer%20in%20that%20it%E2%80%99s%20an%20address%20we%20can%20follow%20to%20access%20the%20data%20stored%20at%20that%20address%3B)

简单来说，引用是一个指针(某个数据的地址)

## Rust 中的引用
引用在 Rust 中有2种情况：

1. 可变引用
```rust
    let mut x = &1;
    *x = *x + 1;    // * 为解引用
```
2. 不可变引用 && 自动解引用
```rust
    let x = &1;
    let y = x + 1; // x 当成一个值与 1 相加。rust 这里对 x 进行了自动解引用
```

可以看到, Rust 的引用与 C 中对指针的操作很相似。

## Wind 中的引用 （设想）
现在我来说说 Wind 中引用的使用。这里借用 Rust 的`自动解引用`概念。

1. 没有 & 取地址符, 引用对象 只能构造产生, 如：
```lisp
    (var x 1''i32)
    (var p {x:100, y:200}''Point)
```

2. 引用总是自动解引用的
```lisp
    (var x 1''i32)
    (var y = 2''i32)
    (x = y)  // 相当于 C 中 *x = *y;
```
3. 给同一个人取 2 个名字?
    
    在第2条中, 可能有人会疑惑, x = y 后，按 C 的语法，不应该是 x, y 都指向 2 吗？
    首先 在同一个函数中，让2个指针指向同一个对象，这相当于同一个人取了 2 个名字, 这种情况是没有太大的意义的。还容易引起 bug。

    第二，它与 第2条 (引用总是自动解引用的) 的语义形成冲突。
    所以 在 Wind 中 "不允许给同一个人取 2 个名字" 或者说无法做到。

## 栈与堆 （逃逸分析）
了解了引用之后, 我们来分析一下内存管理的问题。

先简单介绍一下，栈是存放函数局部变量的地方，堆是动态分配的内存。栈的速度更快，而且随着函数的调用结束, 其占用的栈空间也随之释放。

看一个例子，(var x 1''i32) 我创造了一个引用对象x(指向 1),

那这个 1 是该在栈中还是堆中创建呢？ 这里需要对 x 进行生命周期分析。

如果 x 被当成了该函数的返回值 (或者其他情况, 比如被一个闭包捕获, 该闭包又被当成返回值)。这种情况下，我们说 x `逃逸成功`。

当 x 逃逸之后, x 的生命周期就超出了当前函数帧，所以 x 可能需要被分配到堆中。

### 提前分配
接上文, 为什么我说 "x 可能需要被分配到堆中。" 因为这只是一种处理方法, 我们的目标是尽可能在栈中进行分配。(尤其是小块数据)

还一种方法就是 提前分配：就是在函数调用之前就分配好内存。

例子：
```lisp
    (func (foo)''i32 {
        (var x 1''i32) // 这里内部需要 malloc
        x
    })

    (func (main)'i32 {
        (var x (foo))
        x - 1
    })
```
编译器 提前分配优化后:
```lisp
    (func (foo x''i32)''i32 {
        x = 1
        x
    })

    (func (main)'i32 {
        (var x 0)
        (foo &x) // 伪代码, & 是取地址的意思 
        x - 1
    })
```

## 讨论
通过对引用对象进行逃逸分析，来确定它的生命周期。

通过 提前分配 的优化，将之提前到对应的父级(或者父级的父级...)的栈中进行分配。是否可以做到完全避免 堆内存的分配？
```
还有一种情况需要说明：

比如数组，数组本身是一个 struct (data'ptr, length'i32, capacity'i32), 上面所说的是针对数组本身。

经过优化后，数组本身是放在某个函数的栈中的, 但是数组中的 data 可能是堆中的数据, 我们需要在该函数中该数组变量的生命周期结束后(超出其作用域)，释放 data。
```

## 内存自动管理 (无需GC？吊打 Rust?)
如果上面的一系列设想是成立的, 也就是说我们完全推导出了, 引用对象的生命周期（处于某个函数帧中）。这样的话，我们不需要 GC 了。

没有所有权, 没有生命周期标注等 Rust 复杂概念, Wind 就做到了自动内存管理?

## 不成熟设想, 欢迎讨论～